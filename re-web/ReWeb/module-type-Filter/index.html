<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Filter (re-web.ReWeb.Filter)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">re-web</a> &#x00BB; <a href="../index.html">ReWeb</a> &#x00BB; Filter</nav><h1>Module type <code>ReWeb.Filter</code></h1><p>Transform services. Please see here for documentation.</p><p>The filters here that don't read the request body additionally preserve whatever context was already in the request before the current filter ran. They do this by putting the previous context in a <code>prev</code> method in the new context object. This is just a convention but a useful one.</p><p>The filters which read the body don't do this because they only work with request which have no context (i.e., context of type <code>unit</code>).</p></header><div class="spec module" id="module-Service"><a href="#module-Service" class="anchor"></a><code><span class="keyword">module</span> <a href="Service/index.html">Service</a>: <a href="../Service/index.html#module-type-S">Service.S</a>;</code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('ctx1, 'ctx2, 'resp)</code><code> = <a href="Service/index.html#type-t">Service.t</a><span>(<span class="type-var">'ctx2</span>, <span class="type-var">'resp</span>)</span> <span>=&gt;</span> <a href="Service/index.html#type-t">Service.t</a><span>(<span class="type-var">'ctx1</span>, <span class="type-var">'resp</span>)</span></code>;</dt><dd><p>A filter transforms a service. It can change the request (usually by changing the request context) or the response (by actually running the service and then modifying its response).</p><p>Filters can be composed using function composition.</p></dd></dl><dl><dt class="spec value" id="val-basic_auth"><a href="#val-basic_auth" class="anchor"></a><code><span class="keyword">let</span> basic_auth: <a href="index.html#type-t">t</a><span>(<span class="type-var">'ctx1</span>, {. username: string, password: string, prev: <span class="type-var">'ctx1</span>, }, <a href="../Response/index.html#type-t">Response.t</a>(<span class="type-var">_</span>))</span>;</code></dt><dd><p><code>basic_auth</code> decodes and stores the login credentials sent with the <code>Authorization</code> header or returns a 401 Unauthorized error if there is none.</p></dd></dl><dl><dt class="spec value" id="val-bearer_auth"><a href="#val-bearer_auth" class="anchor"></a><code><span class="keyword">let</span> bearer_auth: <a href="index.html#type-t">t</a><span>(<span class="type-var">'ctx1</span>, {. bearer_token: string, prev: <span class="type-var">'ctx1</span>, }, <a href="../Response/index.html#type-t">Response.t</a>(<span class="type-var">_</span>))</span>;</code></dt><dd><p><code>bearer_auth</code> stores the bearer token sent with the <code>Authorization</code> header or returns a 401 Unauthorized error if there is none.</p></dd></dl><dl><dt class="spec value" id="val-body_form"><a href="#val-body_form" class="anchor"></a><code><span class="keyword">let</span> body_form: <a href="../Form/index.html#type-t">Form.t</a><span>(<span class="type-var">'ctor</span>, <span class="type-var">'ty</span>)</span> <span>=&gt;</span> <a href="index.html#type-t">t</a><span>(unit, <span class="type-var">'ty</span>, <span>[&gt; <a href="../Response/index.html#type-http">Response.http</a> ]</span>)</span>;</code></dt><dd><p><code>body_form(typ)</code> is a filter that decodes a web form in the request body and puts it inside the request for the next service. The decoding is done as specified by the form definition <code>typ</code>. If the form fails to decode, it short-circuits and returns a 400 Bad Request.</p></dd></dl><dl><dt class="spec value" id="val-body_json"><a href="#val-body_json" class="anchor"></a><code><span class="keyword">let</span> body_json: <a href="index.html#type-t">t</a><span>(unit, Ezjsonm.t, <span>[&gt; <a href="../Response/index.html#type-http">Response.http</a> ]</span>)</span>;</code></dt><dd><p><code>body_json</code> is a filter that transforms a 'root' service (i.e. one with <code>unit</code> context) into a service with a context containing the request body. If the request body fails to parse as valid JSON, it short-circuits and returns a 400 Bad Request.</p></dd></dl><dl><dt class="spec value" id="val-body_json_decode"><a href="#val-body_json_decode" class="anchor"></a><code><span class="keyword">let</span> body_json_decode: <span>(Ezjsonm.t <span>=&gt;</span> Stdlib.result<span>(<span class="type-var">'ty</span>, exn)</span>)</span> <span>=&gt;</span> <a href="index.html#type-t">t</a><span>(Ezjsonm.t, <span class="type-var">'ty</span>, <span>[&gt; <a href="../Response/index.html#type-http">Response.http</a> ]</span>)</span>;</code></dt><dd><p><code>body_json_decode(decoder)</code> is a filter that transforms a service with a parsed JSON structure in its context, to a service with a decoded value of type <code>'ty</code> in its context. If the request body fails to decode with <code>decoder</code>, the filter short-circuits and returns a 400 Bad Request.</p></dd></dl><dl><dt class="spec value" id="val-body_string"><a href="#val-body_string" class="anchor"></a><code><span class="keyword">let</span> body_string: <a href="index.html#type-t">t</a><span>(unit, string, <span>[&gt; <a href="../Response/index.html#type-http">Response.http</a> ]</span>)</span>;</code></dt><dd><p><code>body_string</code> is a filter that transforms a 'root' service into a service whose context contains the request body as a single string.</p></dd></dl><dl><dt class="spec value" id="val-cache_control"><a href="#val-cache_control" class="anchor"></a><code><span class="keyword">let</span> cache_control: <a href="../../Header/CacheControl/index.html#type-t">Header.CacheControl.t</a> <span>=&gt;</span> <a href="index.html#type-t">t</a><span>(<span class="type-var">'ctx</span>, <span class="type-var">'ctx</span>, <span>[ <a href="../Response/index.html#type-http">Response.http</a> <span>| <a href="../Response/index.html#type-websocket">Response.websocket</a></span> ]</span>)</span>;</code></dt><dd><p><code>cache_control(policy)</code> is a filter that applies the caching <code>policy</code> policy to the HTTP response.</p></dd></dl><dl><dt class="spec value" id="val-multipart_form"><a href="#val-multipart_form" class="anchor"></a><code><span class="keyword">let</span> multipart_form: <span>typ:<a href="../Form/index.html#type-t">Form.t</a><span>(<span class="type-var">'ctor</span>, <span class="type-var">'ty</span>)</span></span> <span>=&gt;</span> <span>(<span>filename:string</span> <span>=&gt;</span> string <span>=&gt;</span> string)</span> <span>=&gt;</span> <a href="index.html#type-t">t</a><span>(unit, <span class="type-var">'ty</span>, <span>[&gt; <a href="../Response/index.html#type-http">Response.http</a> ]</span>)</span>;</code></dt><dd><p><code>multipart_form(~typ, path)</code> is a filter that decodes multipart form data. <code>typ</code> must be provided but if you don't actually have any other fields in the form you can use <code>Form.empty</code> to decode into an 'empty' (unit) value.</p><p><code>path(~filename, name)</code> is used to get the filesystem absolute path to save the given <code>filename</code> with corresponding form field <code>name</code>. Note that:</p><ul><li>The file will be overwritten if it already exists on disk</li><li><code>filename</code> is the basename, not the full path</li><li>The filter will short-circuit with a 401 Unauthorized error response if any of the files can't be opened for writing.</li></ul><p>This callback gives you a chance to sanitize incoming filenames before storing the files on disk.</p></dd></dl><dl><dt class="spec value" id="val-query_form"><a href="#val-query_form" class="anchor"></a><code><span class="keyword">let</span> query_form: <a href="../Form/index.html#type-t">Form.t</a><span>(<span class="type-var">'ctor</span>, <span class="type-var">'ty</span>)</span> <span>=&gt;</span> <a href="index.html#type-t">t</a><span>(<span class="type-var">'ctx1</span>, {. query: <span class="type-var">'ty</span>, prev: <span class="type-var">'ctx1</span>, }, <a href="../Response/index.html#type-t">Response.t</a>(<span class="type-var">_</span>))</span>;</code></dt><dd><p><code>query_form(typ)</code> is a filter that decodes the request query (the part after the <code>?</code> in the endpoint) into a value of type <code>'ty</code> and stores it in the request context for the next service. The decoding and failure works in the same way as for <code>body_form</code>.</p></dd></dl></div></body></html>